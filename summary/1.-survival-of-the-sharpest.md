# Survival of the Sharpest

## An evolving language

### A helpful type system at large and small scales

The more precisely you can specify the shape of the data your code accepts and returns, the more the compiler can help you avoid mistakes.

```csharp
// C# 1 
public class Bookshelf
{
    public IEnumerable Books { get { ... } }
}



// generics from C# 2
// more fine-grained type control
public class Bookshelf
{
    public IEnumerable<Book> Books { get { ... } } }
}
```

C# 2 also brought nullable value types


C# 3 introduced anonymous types and implicitly typed local variables (var).
Anonymous types are primarily used within LINQ queries

```charp
var book = new { Title = "Lost in the Snow", Author = "Holly Webb" };
string title = book.Title;
string author = book.Author;
```

```charp
// Linq query
private void RunTest()
{
    var v = new[] {
        new { Name="Lee", Age=33, Phone="02-111-1111" },
        new { Name="Kim", Age=25, Phone="02-222-2222" },
        new { Name="Park", Age=37, Phone="02-333-3333" },
    };

    // LINQ Select를 이용해 Name과 Age만 갖는 새 익명타입 객체들을 리턴.
    var list = v.Where(p => p.Age >= 30).Select(p => new { p.Name, p.Age });
    foreach (var a in list)
    {
        Debug.WriteLine(a.Name + a.Age);
    }
}
```

C# 7 introduced tuples: value types that effectively act to collect variables together.
C# 7 C# 7 gave us the ability to tell the compiler that a user-defined struct should be immutable using readonly struct declarations. 


```csharp
var book = (title: "Lost in the Snow", author: "Holly Webb");
Console.WriteLine(book.title);
```

C# 8 The plans for C# 8 include nullable reference types((either as a return value, a parameter, or just a local variable)), which will allow even more com- munication.

```charp
string Method(string x, string? y)
```



